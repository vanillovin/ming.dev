---
title: Big O Notation
date: 2022-04-21
description: Udemy JavaScript 알고리즘 & 자료구조 마스터클래스 강의
---

## Section 2: 빅오 표기법(Big O Notation)

### 빅오 (Big O) 소개
#### 목표
- 빅오 표기법의 필요성
- 표기법을 간단하게 표현하는 법
- "시간 복잡성" 과 "공간 복잡성" 정의
- 빅오 표기법을 사용해 여러가지 알고리즘을 평가
- 로그가 무엇인지 설명

#### What's the idea here? 개념이 정확히 무엇인가요?
이 코스는 알고리즘에 대한 코스. 다양한 문제들을 해결하고 컴퓨터 공학과 데이터 구조에 대한 것.
하지만 이 코스에서 나오는 주제마다, 많은 해결법이 존재할 것인데 그중에 어떤 것이 최고인지 어떻게 평가?
어떤 문제를 루프를 사용하거나, 리스트나 문자열을 이용해 다르게 접근해 해결한다면 어느 것이 더 좋을까?

그것이 빅오의 핵심. 어떠한 시스템! 여러 가지 코드를 일반적으로 서로 비교하고 성능을 평가하는 방법으로
코드를 분류하거나 비교할 수 있는 시스템이 필요해서 그런 목적을 갖고 있음. 비유를 들어 지진에 대해서 얘기를 하고 있다면 
리히터 척도부터 설명했을 것.. 

어쨌든 분류를 할 수 있다는 것 코드를 분류할 수 잇는 것. "좋은", "그저그런" 또는 "엉망인" 코드라고 말하는 대신
숫자로 코드의 성능을 표기할 수 있다는 것!

때로는 제대로 작동하는 코드가 가장 좋은 해결법이지만 면접을 보거나 코드 챌린지를 해결하거나
수천 개의 데이터가 있는 큰 데이터 셋을 다루는 대기업에선 한 알고리즘이 다른 알고리즘보다 실행하는데 
한 시간이 더 빠른 이런 경우엔 성능이 중요. 그런 경우 실제로 가장 좋은 알고리즘이 있음.

그렇기 때문에 코드의 성능을 얘기할 때 정확한 전문용어를 사용하는 것이 중요함.
우리가 만든 해결책이 만족스럽다고 해도 다른 해결책과 비교하고 성능이 어떤지 이해하는 것이 도움 됨!
그리고 코드를 디버그 할 때 코드를 느리게 만드는 것을 이해하는 것이 중요함.

면접을 잘 보기 위해서만 이것을 배우는 것이 아닌 코드를 더 잘 이해하고 더 좋은 코드를 쓰기 위해서
도움이 되는 것..!


### 코드 시간 재기
1부터 특정한 N 값과 사이에 있는 모든 숫자들을 더하는 문제가 있다면 가장 생각하기 쉬운 해결법
```js
function addUpTo(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
}
```

또 다른 해결법. 이 해결법은 루프가 사용 되지 않고 약간 수학 공식에 가까움.
```js
function addUpToSecond(n) {
  return n * (n + 1) / 2;
}
```

2가지 해결법 중 "더 나은" 것이 무엇을 의미? 어떤 코드가 더 빠르다는 것을 의미?
아니면 메모리를 얼마나 사용하는지? 만들어지는 변수의 갯수나 함수를 호출할 때마다 
저장되는 데이터를 말하는 것? 아니면 코드를 얼마나 쉽게 읶을 수 잇는지? 얼마나 짧은지?
대부분 사람들은 최대한 적은 코드를 쓰는 것을 선호함. 

좋은 코드를 쓴다는 것은 많은 메모리 양을 사용하지 않는 효율적인 코드를 쓰면서
읽기 쉬운 점 이 두 가지를 잘 조율하는 것이 중요. 우선은 "속도"를 평가하는 것에 집중!
코드를 실행하는데 걸리는 시간을 어떻게 평가할 수 있을까? 

가장 쉬운 방법은 performance.now라는 내장 타이밍 펑션을 사용하는 것.
이렇게 하면 브라우저가 이 문서를 만든 시간 이 창이 열린 시간을 알려줌
```js
function addUpTo(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
}

let t1 = performance.now();
addUpTo(1000000000);
let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`);
```

전달하고 싶은 점은, 똑같은 데이터를 다루지만 두 번째 함수 코드가 훨씬 더 짧은 시간 안에 해냈다는 것!
이렇게 수동으로 타이밍을 구하고 서로 비교하는 것이 가장 좋은 방법은 아니며 같의 논의하기도 어렵..
이 두 시간을 빼주는 것으론 불확실한 부분이 있고 "시간에 문제"가 있음(The Problem with Time?)
기기 사양과 방식에 따라 다르고 언제나 다른 시간이 기록될 수도 있고 결론은 완전히 믿을 수 없다는 것으로,
이런 식으로 시간을 측정하는 방법 외에 더 좋은 비교 방법이 있었으면 좋겠다는 것 => 빅오 표기법! 


### 연산 갯수 세기
코드를 비교할 때 시간을 비교하는 것에 문제가 있었고 그럼 무엇을 사용할까?
비슷한 개념이지만 코드가 실행될 때 걸리는 정확한 시간을 초로 측정하는 것보다는
컴퓨터가 처리해야 하는 "연산 갯수"를 세면됨. 어떤 컴퓨터를 사용하든 그 갯수는 변하지 않으니까오

이 코드는 연산을 3번 해야 하는 것. N이 크든 작든 어떤 값을 갖고 있든 상관없이 계산은 딱 3번 이루어짐
```js
function addUpToSecond(n) {
  return n * (n + 1) / 2;
}
// 1 multiplication
// 1 addition
// 1 division
```

첫 번째 해결법과 비교하면, 이것은 루프 안에 있기 때문에 조금 다름 N이 1억이라면 1억 번을 더한다는 것.
N이 커질수록 연산의 갯수가 늘어난다는 말. N이 10이라면 연산 50개에 루프 밖에 있는 2개를 더하니까
52라는 뜻.
```js
function addUpTo(n) {
  let total = 0; // 1 assignments
  // 1 assignment / n comparisons / n additions and n assignments
  for (let i = 1; i <= n; i++) {
    total += i; // n addtions n assignments
  }
  return total;
}
```

하지만 정확한 숫자는 사실 상관이 없고 우리에게 중요한 것은 전체적인 추세를 보는 것으로,
빅오를 볼 때 이런 것에 집중하기. 가장 중요한 것은 큰그림! 
이 경우엔 N이 커질수록 연산의 갯수도 비례적으로 늘어난다는 것


### 시간 복잡도 시각화하기
함수가 실행하는데 얼마나 시간이 오래 걸리는지 보여주는 강사님이 만든 위젯으로 
걸리는 시간과 전체적인 추세를 그래프로 보여줌. [Performance Tracker](https://rithmschool.github.io/function-timer-demo/)
& [github md](https://github.com/tesla809/data-structures-algorithms-masterclass/blob/master/BIG_O_NOTATION.md)


### 빅오에 대한 공식 소개
- 빅오는 대략적으로 숫자를 세는 것에 붙인 공식적인 표현. 정식으로 입력된 내용이 늘어날수록
알고리즘 실행 시간이 어떻게 변하는지 설명함. 
- 그리고 빅오는 어떤 펑션의 입력 값이 늘어나는 것과 펑션 실행 시간이 변하는 관계를 의미함.
입력의 크기와 실행 시간의 관계를 말함
- 오로지 전반적인 추세에 주목하는 것임

두 번째 함수에서 N의 값이 늘어났지만, 실행되는 시간에 아무 영향을 받지 않았음.
하지만, 첫 번째 함수는 실행되는 시간의 N의 값이 늘어나는 것과 비례하게 거의 1:1 비율로,
선형으로 늘어났다는 것임. 이게 바로 빅오. 

N이 커질수록 컴퓨터가 f(n) 상수 곱하기 f(n)보다 간단한 연산을 덜 해야 한다면
그 알고리즘을 O(f(n))이라고 표현한다.

몇 가지 선택들. 그냥 n이라는 값이 입력되는 함수로 입력과 실행 시간의 관계를 뜻하는 것임.
- f(n) colud be linear (f(n) = n)
- f(n) colud be quadratic (f(n) = n^)
- f(n) colud be constant (f(n) = 1)
- f(n) colud be something entirely different!

이 예시의 경우 언제나 연산의 3개로 선이 대략적으로 변화가 없음. 
이럴 때는 빅오가 1이라고 표현할 수 있음.
```js
function addUpTo(n) {
  return n * (n + 1) / 2;
}

// Always 3 operations
//       O(1)
```

하지만 이 함수는 n이 커질수록 실행 시간이 1:1 비율로 늘어나고
연산의 갯수는 궁극적으로 N의 곱과 연결돼 있음.
```js
function addUpTo(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
}

// Number of operations is (eventually)
// bounded by a multiple of n (say, 10n)
// => O(n)
```

가능한 짝(pair)의 갯수를 생각해보기. n이 2라면 0,0 0,1 1,0 1,1 
이 함수는 n이 2 짝이 4개 => O(n^2). 하지만 n을 3으로 늘린다면, 갑자기 짝이 9개가 됨.
어쨌든 매우 빠르게 늘어남
```js
function printAllPairs(n) {
  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      console.log(i, j);
    }
  }
}
```

기본적으로 입력인 n이 커질수록 알고리즘이 얼마나 효율적인지 표현하는 방식? 😡


### 빅오 표기법 단순화하기
이 모든 연산들을 다 세는 것이 힘들고 사실 정확한 갯수는 별로 중요하지 않음.
전체적인 추세를 중요하게 여긴다는 것 (5n + 2 => n)

상수는 중요하지 않고 큰 그림이 중요. 상수를 없애버리면 단순화된 것들만 비교할 수 있음.
그러면 바로 [O(1)]이 [O(n)]보다 빠르고 n제곱이 가장 느리다는 것을 그래프 곡선들만 봐도 알 수 있음
- O(2n) x => O(n)
- O(500) x => O(1)
- O(12n^2) x => O(n^2)

앞에 붙는 상수처럼 작은 연산들도 중요하지 않음
- O(n + 10) => O(n)
- O(1000n + 50) => O(n)

항상 맞지는 않지만 쉽게 적용 할 수 잇는 규칙
1. 산수는 상수라는 것. 덧셈, 뺄셈, 곱셈, 나눗셈을 포함함. 변수 배정도 상수고
배열에서 인덱스로 아이템을 찾든 객체의 데이터에 키로 접근하든 비슷한 시간이 걸림
2. 루프가 있으면 복잡도가 루프의 길이 곱하기 루프 안에 있는 연산들이 됨.
그렇게 때문에 리스트에 있는 데이터를 루프로 처리할 때 0에서 n까지 간다면,
n이 커질수록 루프가 반복되는 횟수가 늘어남. 중첩 루프가 있다면 n 제곱 실행 시간

여기 루프가 있는데 결국 5까지 가거나, n까지 반복할 것임. 실행 시간은 만약 n이 1000만이면
이 루프는 1000만 번 반복될 것이니 5는 별로 중요하지 않음 그러면 이 함수의 빅오를
O(n)이라고 단순화해서 말할 수 있음
```js
function logAtLeast5(n) {
  for (var i = 1; i <= Math.max(5, n); i++) {
    console.log(i);
  }
}
```

이건 반대. 5보다 크면 무조건 더 작은 5를 선택할 것이기 때문에 n이 1000이더라도 루프가 5번만 반복됨.
그렇기 때문에 n이 커질수록 빅오는 상수라고 단순화 할 수 있는 것. O(5) => O(1)
```js
function logAtMost5(n) {
  for (var i = 1; i <= Math.min(5, n); i++) {
    console.log(i);
  }
}
```

<img alt="Big-O" src="/posts/note/js-bic-o-notation/Big-O-General-Trend-Of-Algorithms.png" />

일단 어떤 알고리즘을 썼을 때 그 실행 시간이 n 제곱이라면 n보다 더 안 좋다는 것은 분별할 수 있을 것임


### 공간 복잡도
알고리즘들이 얼마나 빠르게 실행하는지 이걸 바로 시간 복잡도, 
입력이 커질수록 알고리즘이 얼마나 많은 공간을 차지 하는지는 공간 복잡도

아직도 빅오 표기법을 사용할 수 있지만 일어나는 현상을 표현하기 위해서 같은 방식으로 표기할 수 있지만
이제는 공간, 사용되는 메모리를 주목

우선 몇 까지 기본적인 것을 짚고 넘어 가자면.
당연한 것은 n이 커질수록, 무한대까지 가면서 입력 자체가 커진다는 것이고
그것은 입력 되는 것을 제외하고 알고리즘 자체가 필요로 하는 공간을 의미함.
공간 복잡도 라고 말했을 때 사실상 보조 공간 복잡도를 말하는 것

몇가지 기본적인 규칙들.
우선 불, 숫자, undefined, null은 자바스크립트에서 모두 불변 공간임.
그렇게 때문에 입력의 크기와는 상관 없이, 숫자가 1이든 1000이든 모두 불변 공간이라고 여김
불이 사실이든 거짓이든 똑같은 공간을 차지함. 문자 열은 조금 다름 문자열은 O(n) 공간이 필요합니다.
만약 n이 문자열의 길이라면, 1000자인 입력이 있다면 좋지 않은 예

만약 50자라면 그 문자열은 길이가 1자인 문자열보다 50배 더 많은 공간을 차지하게 될것임.
reference 타입, 배열과 객체도 같음 대부분 O(n)이라고 생각.
n은 배열의 길이이거나 객체의 키 갯수일 수 있음. 정확히 말하자면 길이는 아니지만, 만약 배열 길이가 4이고
또 하나가 2라면 긴 배열이 짧은 배열보다 2배 더 많은 공간을 차지함

어떤 알고리즘의 공간 복잡도는 엄청 좋고, 어느 한 알고리즘의 시간 복잡도는 엄청 안좋다고,
(n제곱)인 시간 복잡도이지만, 상수 공간 복잡도가 있음


### 로그와 섹션 요약
로그에 대한 개념을 짚고 넘어가는 이유는 어떤 알고리즘들은
O(1), O(n), O(n제곱)처럼 빅오가 간단하지 않은 경우가 있음.
빅오 표기들 중에 더 어렵거나 덜 흔한 수학 개념들이 포함되어 있을 수 있는데
그중 자주 나오는 개념이 로그!

#### 로그란?
짧게 말해서 로그함수는 지수함수의 역함수.
나눗셈과 곱셈이 짝인 것처럼 로그함수와 지수함수는 짝임

이걸 "2를 밑으로 하는 8의 로그는 3과 같다" 라고 읽음
여기서 질문하고 있는것은 "2 몇 승의 값이 8이 되나요?" 묻는 것
```
log2(8) = 3 → 2^3 = 8

log2(value) = exponent → 2^exponent = value
```

로그함수는 항상 2를 밑으로 하지 않음 가장 흔한 것은 log2라고 쓰는 이진 로그로
"2의 몇 승이..?" 로 시작하는 질문을 묻는 것.
```
log === log2
```

인터넷에서 빅오 표기법에 대해서 읽을 수 있는 글들에서는 짧게 log 라고 표현함.
간단한 규칙이 있다면 어떤 이진로그를 대략 계산하기 위해서는 그 숫자가 1보다 작아지기
전에 2로 나눠지는 횟수.
```
// Logarithm Examples
8 (÷2)          25      (÷2)
4 (÷2)          12.5    (÷2)
2 (÷2)          6.25    (÷2)
1               3.125   (÷2)
                0.78125
log(8) = 3
```

25는 정확하게 2로 나눠지지 않음. 계속 나누다 보면 1보다 작아지는데
횟수를 보면 4와 5 사이에 있다는 것을 알 수 있음. 답은 4.64고
실제 계산이 중요하진 않음. 중요한 것은 그래프에 어떻게 보이는지!

빨간색이 상수 시간이고 주황색은 lon n 시간 복잡도로
처음엔 조금 가파르지만, 서서히 경사가 작아지므로 아주 좋음.
또 흔하게 마주치게 될 것은 n log n으로 그래프상 그렇게 좋지는 않지만
그래도 이차 시간 복잡도인 n 제곱보다는 좋음

<img alt="Big-O" src="/posts/note/js-bic-o-notation/Big-O-General-Trend-Of-Algorithms.png" />

이 강의가 바라는 건 나중에 제가 알고리즘 두개를 보여주면서
하나를 가르키면서 "이건 log n 시간이고 이건 O(n) 시간입니다" 라고 말했을 때
이렇게 그래프를 보셔서 "첫번째 (log n)이 더 좋네" 라고 스스로 이해하셨으면 하는 것.

더 효율적이고 더 빠르구나, O(log n)이 O(n)보다 좋구나. n이 커져도 시간이 
별로 늘어나지 않는구나 하지만 O(n)은 많이 늘어나는구나 라고 생각하기.
탐색 알고리즘, 효율적인 정렬 알고리즘과 재귀(再歸) 코스 부분에서 로그를 다시 접하게 됨.
재귀에서는 시간이 아니라 공간 복잡도와 관련되어 있음.

#### 정리
알고리즘의 성능을 분석하기 위해서는 빅오 표기법을 사용함.
정확도가 아니라 전체적인 추세를 중요하게 생각하며,
빅오로 측정되는 알고리즘의 시간과 공간 복잡도는 하드웨어에 영향을 받지 않음.
어느 알고리즘을 나의 컴퓨터와 슈퍼컴퓨터에서 실행하는 속도는 실제로
차이가 있겠지만, 하지만 전반적인 주제는 다르지 않을 것임. 
빅오는 실행될 연산의 개수를 따지기 때문임. 

나의 컴퓨터에서는 10 밀리초가 걸리고 다른 컴퓨터에서는 1 밀리초가 걸리는 그 차이는 중요하지 않음.
빅오 표기법은 세상 모든 곳에서 사용됨. 다시 전에 말했던 지진과 리히터 척도 비유를 다시 꺼낸다면
여러 지진들의 강도를 비교할 수 있는 기준이 생기듯이 이제 알고리즘들을 서로 비교할 수 있음. 
"이건 좋고, 이건 나쁘다."라고 말하면서 "공간 복잡도가 어떻고 시간 복잡도가 어떻다"라고 설명할 수 있게 된 것


### 후기
빅오가 무슨 느낌인지 감은 잡히는데 이게 자막이라서 그냥 반만 이해하고 넘어가는 느낌.. 
구글링이랑 예전에 산 알고리즘 책도 같이 읽으면서 공부해야겠다ㅜㅜ